# -*- coding: utf-8 -*-
"""전력데이터_EDA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dle8_utmi7ZtxNtrxhexBK6BpDPKdHEw
"""

import numpy as np
import pandas as pd

"""## 데이터 확인하기"""

data = pd.read_csv("/content/data_week2.csv", encoding='cp949')

data

# 변수명 변경
data.rename(columns={
    '전력사용량(kWh)': '전력사용량',
    '기온(°C)': '기온',
    '풍속(m/s)': '풍속',
    '습도(%)': '습도',
    '강수량(mm)': '강수량',
    '일조(hr)': '일조'
}, inplace=True)

# 결과 출력
print(data.columns)

data.info()

"""## 데이터 전처리"""

data["num"] = data["num"].astype("object")
data[["비전기냉방설비운영", "태양광보유"]] = data[["비전기냉방설비운영", "태양광보유"]].astype("bool")

data.info()

# date_time 열을 datetime 형식으로 변환
data['date_time'] = pd.to_datetime(data['date_time'])

# 월, 일, 시를 각각 새로운 열로 추가
data['월'] = data['date_time'].dt.month
data['일'] = data['date_time'].dt.day
data['시'] = data['date_time'].dt.hour

# 요일 컬럼 추가 (월요일, 화요일, ...)
data['요일'] = data['date_time'].dt.day_name()

# 주말/평일 컬럼 추가 (0: 평일, 1: 주말)
data['주말_평일'] = data['date_time'].dt.weekday.apply(lambda x: 1 if x >= 5 else 0)

data

data["주말_평일"] = data["주말_평일"].astype("bool")

"""### 변수 시각화"""

#!sudo apt-get install -y fonts-nanum
#!sudo fc-cache -fv
#!rm ~/.cache/matplotlib -rf

import matplotlib.pyplot as plt
plt.rc('font', family='NanumBarunGothic')
plt.figure(figsize=(6, 4))
plt.text(0.5, 0.5, '한글 폰트 테스트', size=15)
plt.show()

"""* 요일별 전력사용량"""

import matplotlib.pyplot as plt

# 요일별로 전력 사용량의 평균을 계산
data_grouped = data.groupby('요일')['전력사용량'].mean()

# 요일 순서 설정 (월요일 ~ 일요일)
days_order = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
data_grouped = data_grouped.reindex(days_order)

# 요일별 전력 사용량 시각화
data_grouped.plot(kind='bar', figsize=(10, 6), color='skyblue')
plt.title('요일별 전력 사용량')
plt.ylabel('평균 전력 사용량')
plt.xlabel('요일')
plt.show()

"""* 평일/주말별 전력사용량"""

import matplotlib.pyplot as plt

# 주말_평일 별로 전력 사용량의 평균을 계산
data_grouped_1 = data.groupby('주말_평일')['전력사용량'].mean()

# 주말_평일 별 전력 사용량 시각화
data_grouped_1.plot(kind='bar', figsize=(10, 6), color='skyblue')

# X축 레이블을 평일/주말로 변경
plt.xticks([0, 1], ['평일', '주말'], rotation=0)

# 그래프 제목과 레이블
plt.title('평일/주말 별 전력 사용량')
plt.ylabel('평균 전력 사용량 (kWh)')
plt.xlabel('평일/주말')

plt.show()

"""* 월별 전력사용량"""

# 월별로 전력 사용량의 평균을 계산
data_grouped_1 = data.groupby('월')['전력사용량'].mean()

# 월별 전력 사용량 시각화
data_grouped_1.plot(kind='bar', figsize=(10, 6), color='skyblue')

# 그래프 제목과 레이블
plt.xticks(rotation=0)
plt.title('월별 전력 사용량')
plt.ylabel('평균 전력 사용량')
plt.show()

"""* 시간대별 전력사용량"""

# 시간대별로 전력 사용량의 평균을 계산
data_grouped_2 = data.groupby('시')['전력사용량'].mean()

# 시간대별 전력 사용량 선그래프 시각화
plt.figure(figsize=(10, 6))
plt.plot(data_grouped_2.index, data_grouped_2.values, marker='o', linestyle='-', color='skyblue')

# 그래프 제목과 레이블
plt.title('시간대별 전력 사용량')
plt.ylabel('평균 전력 사용량')
plt.xlabel('시간대')
plt.xticks(range(0, 24))
plt.grid(True)  # 그리드 추가
plt.show()

import matplotlib.pyplot as plt

# 각 월별로 전력 사용량 평균 계산
data_grouped_6 = data[data['월'] == 6].groupby('시')['전력사용량'].mean()
data_grouped_7 = data[data['월'] == 7].groupby('시')['전력사용량'].mean()
data_grouped_8 = data[data['월'] == 8].groupby('시')['전력사용량'].mean()

# 시간대별 전력 사용량 선그래프 시각화
plt.figure(figsize=(10, 6))

# 각 월별로 선 그리기
plt.plot(data_grouped_6.index, data_grouped_6.values, marker='o', linestyle='-', color='skyblue', label='6월')
plt.plot(data_grouped_7.index, data_grouped_7.values, marker='o', linestyle='-', color='orange', label='7월')
plt.plot(data_grouped_8.index, data_grouped_8.values, marker='o', linestyle='-', color='lightgreen', label='8월')

# 그래프 제목과 레이블
plt.title('시간대별 전력 사용량 (6월, 7월, 8월)')
plt.ylabel('평균 전력 사용량')
plt.xlabel('시간대')
plt.xticks(range(0, 24))
plt.grid(True)  # 그리드 추가

# 범례 추가
plt.legend()
plt.show()

"""* 기온별 전력사용량"""

print(data["기온"].min(), data["기온"].max())

# 산점도 시각화
plt.figure(figsize=(18, 6))
plt.scatter(data['기온'], data['전력사용량'], color='skyblue', alpha=0.7, s=2)

# 그래프 제목과 레이블
plt.title('기온별 전력 사용량 (산점도)')
plt.xlabel('기온')
plt.ylabel('전력 사용량')
plt.xticks(range(int(data['기온'].min()), int(data['기온'].max()) + 1))  # 기온 범위에 맞게 x축 설정
plt.grid(True)  # 그리드 추가
plt.show()

"""* 태양광 보유 유무에 따른 전력사용량"""

import seaborn as sns
# Boxplot 시각화
plt.figure(figsize=(10, 6))
sns.boxplot(x='태양광보유', y='전력사용량', data=data)
plt.xticks([0, 1], ['비보유', '보유'], rotation=0)
plt.title('태양광 보유 여부에 따른 전력 사용량 분포')
plt.xlabel('태양광 보유 여부 (0: 비보유, 1: 보유)')
plt.ylabel('전력사용량 (kWh)')
plt.show()

# Bar plot 시각화 (평균값)
plt.figure(figsize=(10, 6))
sns.barplot(x='태양광보유', y='전력사용량', data=data)

# X축 레이블을 평일/주말로 변경
plt.xticks([0, 1], ['비보유', '보유'], rotation=0)
plt.title('태양광 보유 여부에 따른 전력 사용량 평균')
plt.xlabel('태양광 보유 여부 (0: 비보유, 1: 보유)')
plt.ylabel('전력사용량 (kWh)')
plt.show()

"""- 전력사용량이 많은 곳일수록 태양광 보유하고 있는 거 같음 (더 자세한 분석 필요)
- 맞다면 결론 때 전력사용량+일사량 내림차순 정렬해서 상위 n곳에 태양광발전량 설치
- 근데 상관분석 해봐야 할 거 같음 ex) 전력사용량 뿐만 아니라 평균기온이 제일 관계있다면 평균기온+일사량 이렇게 내림차순 해야될 수도?

* 비전기냉방설비운영 여부에 따른 전력사용량 평균
"""

import seaborn as sns
# Boxplot 시각화
plt.figure(figsize=(10, 6))
sns.boxplot(x='비전기냉방설비운영', y='전력사용량', data=data)
plt.xticks([0, 1], ['비보유', '보유'], rotation=0)
plt.title('비전기냉방설비운영 여부에 따른 전력 사용량 분포')
plt.xlabel('비전기냉방설비운영 여부 (0: 비보유, 1: 보유)')
plt.ylabel('전력사용량 (kWh)')
plt.show()

# Bar plot 시각화 (평균값)
plt.figure(figsize=(10, 6))
sns.barplot(x='비전기냉방설비운영', y='전력사용량', data=data)

# X축 레이블을 평일/주말로 변경
plt.xticks([0, 1], ['비보유', '보유'], rotation=0)
plt.title('비전기냉방설비운영 여부에 따른 전력 사용량 평균')
plt.xlabel('비전기냉방설비운영 여부 (0: 비보유, 1: 보유)')
plt.ylabel('전력사용량 (kWh)')
plt.show()

"""* 전력사용량을 많이 쓰는 곳일수록 비전기냉방설비를 많이 보유하고 있다는 곳이라고 생각할 수 있음

### 이상치 확인1
같은 건물번호 내 태양광보유값 다른게 있는지
"""

# 태양광보유가 0인 것들만 필터링
filtered_data0 = data[data['태양광보유'] == 0]
# 태양광보유가 1인 것들만 필터링
filtered_data1 = data[data['태양광보유'] == 1]

# 건물 번호(num)를 기준으로 그룹화하여 태양광보유 열의 합계 계산
solar_sum_by_building0 = filtered_data0.groupby('num')['태양광보유'].sum()
solar_sum_by_building1 = filtered_data1.groupby('num')['태양광보유'].sum()

# 결과 출력
print(solar_sum_by_building0, solar_sum_by_building1)

"""-> 없음

### 이상치 확인2
"""



"""### 이상치 확인3

* 기초통계량
"""

data.describe()

"""* 시각화"""

# 6월 데이터만 필터링
june_data = data[(data['date_time'].dt.month == 6)]

# 건물별 전력 사용량 데이터를 피벗
june_pivot = june_data.pivot_table(index=june_data['date_time'], columns='num', values='전력사용량', aggfunc='mean')

# 그래프 설정
plt.figure(figsize=(14, 10))
for column in june_pivot.columns:
    plt.plot(june_pivot.index.hour, june_pivot[column], label=f'건물 {column}', alpha=0.7)

# 그래프 꾸미기
plt.title('건물별 전력 사용량 (6월, 시간대별)', fontsize=18)
plt.xlabel('시간 (0시 ~ 24시)', fontsize=14)
plt.ylabel('전력 사용량 (kWh)', fontsize=14)
plt.xticks(range(0, 24))  # 0시부터 24시까지 x축 눈금
plt.grid(True, linestyle='--', alpha=0.5)
plt.legend(title='건물 번호', bbox_to_anchor=(1.05, 1), loc='upper left', fontsize=10)
plt.tight_layout()
plt.show()

# 7월 데이터만 필터링
june_data = data[(data['date_time'].dt.month == 7)]

# 건물별 전력 사용량 데이터를 피벗
june_pivot = june_data.pivot_table(index=june_data['date_time'], columns='num', values='전력사용량', aggfunc='mean')

# 그래프 설정
plt.figure(figsize=(14, 10))
for column in june_pivot.columns:
    plt.plot(june_pivot.index.hour, june_pivot[column], label=f'건물 {column}', alpha=0.7)

# 그래프 꾸미기
plt.title('건물별 전력 사용량 (7월, 시간대별)', fontsize=18)
plt.xlabel('시간 (0시 ~ 24시)', fontsize=14)
plt.ylabel('전력 사용량 (kWh)', fontsize=14)
plt.xticks(range(0, 24))  # 0시부터 24시까지 x축 눈금
plt.grid(True, linestyle='--', alpha=0.5)
plt.legend(title='건물 번호', bbox_to_anchor=(1.05, 1), loc='upper left', fontsize=10)
plt.tight_layout()
plt.show()

june_pivot

"""* 건물 유형이 비슷한 애들끼리 묶고 비교"""

!pip install tslearn

import pandas as pd
import matplotlib.pyplot as plt
import tslearn
from tslearn.clustering import TimeSeriesKMeans
from tslearn.preprocessing import TimeSeriesScalerMeanVariance
import numpy as np

# date_time을 datetime 형식으로 변환
data['date_time'] = pd.to_datetime(data['date_time'])

# 건물별 전력 사용량 데이터를 시간대별로 피벗 (각 건물의 24시간 동안의 평균 전력 사용량)
pivot_data = data.pivot_table(index=data['date_time'].dt.hour, columns='num', values='전력사용량', aggfunc='mean')

# 피벗 테이블을 numpy 배열로 변환하여 클러스터링에 사용할 수 있는 형식으로 변환 (건물, 시간대)
pivot_data_values = pivot_data.T.values  # shape: (60 건물, 24시간)

# 시계열 데이터 스케일링 (평균과 분산을 표준화)
scaler = TimeSeriesScalerMeanVariance(mu=0.0, std=1.0)
scaled_data = scaler.fit_transform(pivot_data_values)

# DTW 기반 K-Means 클러스터링 (k=3, 클러스터 수 조정 가능)
model = TimeSeriesKMeans(n_clusters=3, metric="dtw", verbose=True, random_state=42)
clusters = model.fit_predict(scaled_data)

# 클러스터 결과를 데이터프레임으로 정리 (건물 번호와 매칭)
cluster_df = pd.DataFrame({'num': pivot_data.columns, 'Cluster': clusters})

# 클러스터 결과를 시각화
plt.figure(figsize=(12, 8))
for cluster_num in range(3):  # 클러스터 수에 따라 범위 조정
    cluster_buildings = cluster_df[cluster_df['Cluster'] == cluster_num]['num']
    for building in cluster_buildings:
        plt.plot(pivot_data.index, pivot_data[building], label=f'건물 {building}', alpha=0.6)

plt.title('Clustered Power Usage Patterns (by Hour)', fontsize=16)
plt.xlabel('Hour of the Day', fontsize=12)
plt.ylabel('Power Usage (kWh)', fontsize=12)
plt.grid(True, linestyle='--', alpha=0.5)
plt.tight_layout()
plt.show()

cluster_df

# 클러스터가 0인 건물들만 필터링
cluster_0_buildings = cluster_df[cluster_df['Cluster'] == 0]['num']

# 클러스터 0에 속하는 건물들의 전력 사용량 시각화
plt.figure(figsize=(12, 8))
for building in cluster_0_buildings:
    plt.plot(pivot_data.index, pivot_data[building], label=f'건물 {building}', alpha=0.7)

plt.title('Cluster 0 - Power Usage Patterns (by Hour)', fontsize=16)
plt.xlabel('Hour of the Day', fontsize=12)
plt.ylabel('Power Usage (kWh)', fontsize=12)
plt.grid(True, linestyle='--', alpha=0.5)
plt.legend(title='건물 번호', bbox_to_anchor=(1.05, 1), loc='upper left', fontsize=10)
plt.tight_layout()
plt.show()

# 클러스터가 0인 건물들만 필터링
cluster_0_buildings = cluster_df[cluster_df['Cluster'] == 1]['num']

# 클러스터 0에 속하는 건물들의 전력 사용량 시각화
plt.figure(figsize=(12, 8))
for building in cluster_0_buildings:
    plt.plot(pivot_data.index, pivot_data[building], label=f'건물 {building}', alpha=0.7)

plt.title('Cluster 1 - Power Usage Patterns (by Hour)', fontsize=16)
plt.xlabel('Hour of the Day', fontsize=12)
plt.ylabel('Power Usage (kWh)', fontsize=12)
plt.grid(True, linestyle='--', alpha=0.5)
plt.legend(title='건물 번호', bbox_to_anchor=(1.05, 1), loc='upper left', fontsize=10)
plt.tight_layout()
plt.show()

# 클러스터가 2인 건물들만 필터링
cluster_2_buildings = cluster_df[cluster_df['Cluster'] == 2]['num']

# 클러스터 2에 속하는 건물들의 전력 사용량 시각화
plt.figure(figsize=(12, 8))
for building in cluster_2_buildings:
    plt.plot(pivot_data.index, pivot_data[building], label=f'건물 {building}', alpha=0.7)

plt.title('Cluster 2 - Power Usage Patterns (by Hour)', fontsize=16)
plt.xlabel('Hour of the Day', fontsize=12)
plt.ylabel('Power Usage (kWh)', fontsize=12)
plt.grid(True, linestyle='--', alpha=0.5)
plt.legend(title='건물 번호', bbox_to_anchor=(1.05, 1), loc='upper left', fontsize=10)
plt.tight_layout()
plt.show()

cluster_solar_df = cluster_df.merge(data[['num', '태양광보유']].drop_duplicates(), on='num', how='left')
cluster_solar_df

# 클러스터가 0인 건물들 태양광 보유 여부
cluster_0_solar = cluster_solar_df[cluster_solar_df['Cluster'] == 0]
print("Cluster 0 - 태양광 보유 여부")
print(cluster_0_solar['태양광보유'].value_counts())
print("\n")

# 클러스터가 1인 건물들 태양광 보유 여부
cluster_1_solar = cluster_solar_df[cluster_solar_df['Cluster'] == 1]
print("Cluster 1 - 태양광 보유 여부")
print(cluster_1_solar['태양광보유'].value_counts())
print("\n")

# 클러스터가 2인 건물들 태양광 보유 여부
cluster_2_solar = cluster_solar_df[cluster_solar_df['Cluster'] == 2]
print("Cluster 2 - 태양광 보유 여부")
print(cluster_2_solar['태양광보유'].value_counts())
print("\n")

# 클러스터 0 태양광 보유 여부 시각화
plt.figure(figsize=(6, 4))
cluster_0_solar['태양광보유'].value_counts().plot(kind='bar', color=['skyblue', 'orange'])
plt.title('Cluster 0 - Solar Panel Ownership')
plt.xlabel('태양광 보유 여부')
plt.ylabel('Number of Buildings')
plt.xticks([0, 1], ['미보유', '보유'], rotation=0)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

# 클러스터 1 태양광 보유 여부 시각화
plt.figure(figsize=(6, 4))
cluster_1_solar['태양광보유'].value_counts().plot(kind='bar', color=['skyblue', 'orange'])
plt.title('Cluster 1 - Solar Panel Ownership')
plt.xlabel('태양광 보유 여부')
plt.ylabel('Number of Buildings')
plt.xticks([0, 1], ['미보유', '보유'], rotation=0)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

# 클러스터 2 태양광 보유 여부 시각화
plt.figure(figsize=(6, 4))
cluster_2_solar['태양광보유'].value_counts().plot(kind='bar', color=['skyblue', 'orange'])
plt.title('Cluster 2 - Solar Panel Ownership')
plt.xlabel('태양광 보유 여부')
plt.ylabel('Number of Buildings')
plt.xticks([0, 1], ['미보유', '보유'], rotation=0)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

# 건물별 전력 사용량 데이터를 피벗
pivot_data = data.pivot_table(index=data['date_time'], columns='num', values='전력사용량', aggfunc='mean')

# 각 건물의 전력 사용량 최대값과 최소값 계산
max_min_diff = pivot_data.max() - pivot_data.min()

# 기준 설정 (예: 최대 최소 차이가 1500 이하인 경우)
threshold = 1500

# 조건에 따라 건물 분류
stable_buildings = max_min_diff[max_min_diff <= threshold].index.tolist()  # 안정적인 건물
unstable_buildings = max_min_diff[max_min_diff > threshold].index.tolist()   # 불안정한 건물

print("안정적인 건물:", stable_buildings)
print("불안정한 건물:", unstable_buildings)

# 건물별 전력 사용량 데이터를 피벗
pivot_data = data.pivot_table(index=data['date_time'], columns='num', values='전력사용량', aggfunc='mean')

# 각 건물의 전력 사용량 최대값과 최소값 계산
max_min_diff = pivot_data.max() - pivot_data.min()

# 기준 설정 (예: 최대 최소 차이가 1500 이하인 경우)
threshold = 1500

# 조건에 따라 건물 분류
stable_buildings = max_min_diff[max_min_diff <= threshold].index.tolist()  # 안정적인 건물
unstable_buildings = max_min_diff[max_min_diff > threshold].index.tolist()   # 불안정한 건물

# 태양광 보유 여부를 포함한 데이터프레임 생성
solar_info = data[['num', '태양광보유']].drop_duplicates()

# 안정적인 건물 데이터프레임
stable_buildings_df = pd.DataFrame({'num': stable_buildings})
stable_buildings_df = stable_buildings_df.merge(solar_info, on='num', how='left')

# 불안정한 건물 데이터프레임
unstable_buildings_df = pd.DataFrame({'num': unstable_buildings})
unstable_buildings_df = unstable_buildings_df.merge(solar_info, on='num', how='left')

# 결과 출력
print("안정적인 건물 데이터프레임:")
print(stable_buildings_df)

print("\n불안정한 건물 데이터프레임:")
print(unstable_buildings_df)

# 태양광 보유 여부를 정수형으로 변환 (0: 보유 안함, 1: 보유)
stable_buildings_df['태양광보유'] = stable_buildings_df['태양광보유'].astype(int)

# 건물별 태양광 보유 여부 집계
solar_counts = stable_buildings_df.groupby('num')['태양광보유'].max().value_counts().reset_index()
solar_counts.columns = ['태양광보유', '건물수']

# 결과 확인
print(solar_counts)

# 시각화
plt.figure(figsize=(8, 5))
sns.barplot(data=solar_counts, x='태양광보유', y='건물수', palette='Set2')
plt.title('태양광 보유 여부에 따른 건물 수', fontsize=16)
plt.xlabel('태양광 보유 여부 (0: 보유 안함, 1: 보유)', fontsize=12)
plt.ylabel('건물 수', fontsize=12)
plt.xticks(ticks=[0, 1], labels=['보유 안함', '보유'], rotation=0)
plt.tight_layout()
plt.show()

# 태양광 보유 여부를 정수형으로 변환 (0: 보유 안함, 1: 보유)
unstable_buildings_df['태양광보유'] = unstable_buildings_df['태양광보유'].astype(int)

# 건물별 태양광 보유 여부 집계
solar_counts = unstable_buildings_df.groupby('num')['태양광보유'].max().value_counts().reset_index()
solar_counts.columns = ['태양광보유', '건물수']

# 결과 확인
print(solar_counts)

# 시각화
plt.figure(figsize=(8, 5))
sns.barplot(data=solar_counts, x='태양광보유', y='건물수', palette='Set2')
plt.title('태양광 보유 여부에 따른 건물 수', fontsize=16)
plt.xlabel('태양광 보유 여부 (0: 보유 안함, 1: 보유)', fontsize=12)
plt.ylabel('건물 수', fontsize=12)
plt.xticks(ticks=[0, 1], labels=['보유 안함', '보유'], rotation=0)
plt.tight_layout()
plt.show()

"""### 상관관계"""

# 데이터의 date_time 열을 datetime 형식으로 변환
data['date_time'] = pd.to_datetime(data['date_time'])

# 수치형 데이터 선택
numeric_columns = data.select_dtypes(include=['float64', 'int64']).columns

# 상관계수 계산
correlation_matrix = data[numeric_columns].corr()

# 히트맵으로 시각화
plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix, annot=True, fmt=".2f", cmap='coolwarm', square=True, cbar=True, linewidths=0.5)
plt.title('Correlation Heatmap')
plt.show()

# 수치형 데이터 선택 (bool을 포함)
numeric_columns = data.select_dtypes(include=['float64', 'int64', 'bool']).columns

# 상관계수 계산
correlation_matrix = data[numeric_columns].corr()

# 태양광보유 변수와 다른 변수들 간의 상관관계 추출
solar_corr = correlation_matrix['태양광보유'].sort_values(ascending=False)

print("태양광보유와 상관관계가 높은 변수들:")
print(solar_corr)

"""[태양광 설치시 일사량 제외 다른 의미있는 변수를 알아내기 위한 작업]

1. 현재 데이터에서 태양광보유여부와 관련이 있는 특징이 있는지 알아보고자 했으나 원데이터 상관관계 분석결과 없음

2. 새로운 변수(추가는 안함) 시간대별 그래프 추이로 건물 유형을 나누어 유형별 태양광보유와 관계가 있나 파악해봄
* k클러스터링 기법(3가지 유형): 딱히 유형별로 태양광보유여부가 달라지지 않음
* 전력사용량 변동 있/없(minmax1500기준): 딱히 유형별로 태양광보유여부가 달라지지 않음

### 일준님이 시킨거
"""

# 건물별 시간대별 평균 전력 사용량 계산
hourly_mean = data.groupby(['num', '시'])['전력사용량'].mean().reset_index()
hourly_mean

# 그래프 설정
plt.figure(figsize=(14, 10))

# 각 건물의 평균 전력 사용량 시각화
for building in hourly_mean['num'].unique():
    building_data = hourly_mean[hourly_mean['num'] == building]
    plt.plot(building_data['시'], building_data['전력사용량'], label=f'건물 {building}', alpha=0.7)

# 그래프 꾸미기
plt.title('건물별 시간대별 평균 전력 사용량', fontsize=18)
plt.xlabel('시간 (0시 ~ 23시)', fontsize=14)
plt.ylabel('평균 전력 사용량 (kWh)', fontsize=14)
plt.xticks(range(0, 24))  # 0시부터 23시까지 x축 눈금
plt.grid(True, linestyle='--', alpha=0.5)
plt.legend(title='건물 번호', bbox_to_anchor=(1.05, 1), loc='upper left', fontsize=10)
plt.tight_layout()
plt.show()

